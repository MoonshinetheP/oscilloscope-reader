'''
===================================================================================================
Copyright (C) 2023 Steven Linfield

This file is part of the oscilloscope-reader package. This package is free software: you can 
redistribute it and/or modify it under the terms of the GNU General Public License as published by 
the Free Software Foundation, either version 3 of the License, or (at your option) any later 
version. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details. You should have received a copy of the GNU General 
Public License along with oscilloscope-reader. If not, see https://www.gnu.org/licenses/
===================================================================================================

Package title:      oscilloscope-reader
Repository:         https://github.com/MoonshinetheP/oscilloscope-reader
Date of creation:   22/10/2022
Main author:        Steven Linfield (MoonshinetheP)
Collaborators:      None
Acknowledgements:   None

Filename:           operations.py

===================================================================================================

Description:

This file contains the code used by the oscilloscope-reader package to analyse oscilloscope data,
both simulated and imported. On its own, it will work out the position of the vertex potentials
from the oscilloscope data and update the potential waveform accordingly. Returned data can be in
its raw format, the result of a moving average operation, or the result of a current sampling
routine.

===================================================================================================

How to use this file:
    
This file has no standalone operational capabilities.

===================================================================================================

Note:

The functions for analysing the data are relatively simple, but the function for calculating the
position of the vertex potentials is a little more complicated. Currently, the programme works by
finding the highest point of each transient (i.e. the start), which works very well for simulated
data, but not as well for imported data, since the maximum point is not guaranteed to be the first
point of each transient and the rise of the transient itself is often comprised of several 
hundred data points. It does a good enough job for finding the vertex potentials, but is not as
efficient when it comes to current sampling between the peaks. Moving average analysis is not 
affected.

===================================================================================================
'''


import sys
import numpy as np


class Operations:

    '''Analyses the given data and uses it to format the given potential waveform \n

    Requires: \n
    shape - an instance of one of the potential waveform classes from the waveforms.py file\n
    data - an instance of either the Capacitance class from the simulations.py file or the Oscilloscope class from the fileopener.py file\n
    MA - a True or False option for whether moving average analysis is performed \n
    window - the window used for moving average anaysis \n
    step - the steps taken in moving average analysis \n 
    CS - a True or False option for whether current sampling analysis is performed \n
    alpha - the fraction of the step interval (from the end) which is averaged during current sampling analysis'''
    
    def __init__(self, shape, data, MA = False, window = 1000, step = 100, CS = False, alpha = 0.5):
        
        '''PARAMETER INITIALISATION'''
        self.shape = shape      # potential waveform object generated by waveforms.py
        self.data = data        # simulated or imported oscilloscope data object generated using simulations.py or operations.py
        self.MA = MA        # boolean value which decides if moving average analysis is performed or not
        self.window = window        # window used to average the data in moving average analysis
        self.step = step        # steps by which window is moved in moving average analysis
        self.CS = CS        # boolean value which decides if current sampling analysis is performed or not
        self.alpha = alpha      # fraction of interval which is averaged in current sampling analysis

        '''DATA TYPE ERRORS'''
        if isinstance(self.MA, (bool)) is False:
            print('\n' + 'An invalid datatype was used for the moving average option. Enter a Boolean value.' + '\n')
            sys.exit()
        if isinstance(self.window, (int)) is False:
            print('\n' + 'An invalid datatype was used for the moving average window. Enter an integer value.' + '\n')
            sys.exit()
        if isinstance(self.step, (int)) is False:
            print('\n' + 'An invalid datatype was used for the moving average step. Enter an integer value.' + '\n')
            sys.exit()
        if isinstance(self.CS, (bool)) is False:
            print('\n' + 'An invalid datatype was used for the current sampling option. Enter a Boolean value.' + '\n')
            sys.exit()
        if isinstance(self.alpha, (float)) is False:
            print('\n' + 'An invalid datatype was used for the current sampling fraction. Enter a float value.' + '\n')
            sys.exit()

        '''DATA VALUE ERRORS'''
        if self.window <= 1:      # checks that the given moving average window is greater than 1
            print('\n' + 'Moving average window must be greater than 1.' + '\n')
            sys.exit()
        if self.step <= 0:       # checks that the given moving average step is greater than 0
            print('\n' + 'Moving average step must be greater than 0.' + '\n')
            sys.exit() 
        if self.alpha < 0.05 or self.alpha > 0.95:       # checks that the given current sampling fraction is between 0.05 and 0.95 
            print('\n' + 'Current sampling fraction must be between 0.05 and 0.95' + '\n')
            sys.exit() 

        '''CONTROL STATEMENTS'''
        if shape.type == 'linear' and data.label == 'simulated':        # imports the potential and avoids the need to find intervals and vertices
            self.E = self.shape.E
        else:       # all other cases need to at least find the intervals 
            self.Peaks()      

        if self.MA == False and self.CS == False:       # returns with unanalysed raw data
            self.Raw()
        if self.MA == True and self.CS == False:        # returns with moving average analysed data
            self.MovingAverage()
        if self.MA == False and self.CS == True:        # returns with current sampling analysed data
            self.CurrentSampling()
        if self.MA == True and self.CS == True:     # restricts both moving average and current sampling analysis from being performed
            print('\n' + 'Both analysis methods have been selected. Please choose either one or neither in order to get the raw data' + '\n')
            sys.exit()


    def Peaks(self):
        '''Uses a moving window to find the position of the maximum point in each interval \n 
        (i.e. the peak of the transient), uses this data to extract the peak values, then \n 
        looks at the difference between peak values to determine where the vertex potentials are \n
        and recalculates the potential waveform used for plotting based on this data'''
        
        '''FINDING PEAK POSITIONS'''
        ix = 0
        self.peaks = np.array([])
        while ix < (self.data.i.size - self.shape.interval + 1):
            self.position = np.argmax(np.abs(self.data.i[ix : ix + self.shape.interval])) + ix
            if ix == 0:
                self.peaks = np.append(self.peaks, self.position)
            elif self.position - self.peaks[-1] > 1.5 * self.shape.interval:
                self.peaks = np.append(self.peaks, ix + (self.position - self.peaks[-1]) / 2)
                self.peaks = np.append(self.peaks, self.position)
            elif self.position - self.peaks[-1] < 0.5 * self.shape.interval:
                pass
            else:
                self.peaks = np.append(self.peaks, self.position)
            ix += self.shape.interval

        '''FINDING PEAK VALUES'''
        self.values = np.array([])
        for iy in self.peaks:
            self.values = np.append(self.values, self.data.i[int(iy)])

        '''FINDING VERTEX POTENTIALS'''
        if self.data.label == 'imported':
            iz = 0
            self.spacing = np.diff(self.values)
            for iz in self.spacing:
                if iz >= np.abs(self.values[1]):
                    self.lv = int(self.peaks[np.where(self.spacing == iz)[0][0]])
                    if self.shape.dE > 0:
                            self.E = np.concatenate((self.shape.E[self.shape.udp + self.shape.dp - self.lv: ], self.shape.E[:self.shape.udp + self.shape.dp -self.lv]))
                    elif self.shape.dE <0:
                            self.E = np.concatenate((self.shape.E[self.shape.ldp - self.lv: ], self.shape.E[:self.shape.ldp - self.lv]))
                    break
                elif iz <= -np.abs(self.values[1]):
                    self.uv = int(self.peaks[np.where(self.spacing == iz)[0][0]])
                    if self.shape.dE > 0:
                            self.E = np.concatenate((self.shape.E[self.shape.udp - self.uv: ], self.shape.E[:self.shape.udp - self.uv]))
                    elif self.shape.dE <0:
                            self.E = np.concatenate((self.shape.E[self.shape.dp + self.shape.ldp - self.uv: ], self.shape.E[:self.shape.dp + self.shape.ldp - self.uv]))
                    break                         
        else:       # no need to find the vertex potentials for simulated data
            self.E = self.shape.E


    def Raw(self):
        '''Simply returns the oscilloscope data in its raw form'''
        
        self.method = 'no formatting'       # label for file naming
            
        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        self.E = self.E
        self.i = self.data.i[:self.E.size]


    def MovingAverage(self):
        '''Returns the moving average of the oscilloscope data in the form of voltage (detailed) vs. averaged current''' 
        
        self.method = f'moving average analysis using a window of {self.window} and steps of {self.step} '      # label for file naming
        
        ix = 0
        self.i = np.array([])
        while ix < self.data.i.size - self.window + 1:
            self.i = np.append(self.i, np.average(self.data.i[ix : ix + self.window]))
            ix += self.step

        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        self.E = self.E[::self.step][:self.i.size]
        self.i = self.i[:self.E.size]
        

    def CurrentSampling(self):
        '''Returns the current average of each potential step in the oscilloscope data in the form of voltage (simplified) vs. averaged current'''
        
        self.method = f'current sampling analysis using an alpha of {self.alpha}'       #label for file naming

        self.i = np.array([])
        for ix in range(0, self.peaks.size):
            try:
                data = self.data.i[int(self.peaks[ix] + (0.025 * self.shape.interval)): int(self.peaks[ix + 1] - (0.025 * self.shape.interval))]
            except:
                data = self.data.i[int(self.peaks[ix] + (0.025 * self.shape.interval)):] 
            period = self.alpha * (data.size)                                                    
            sampled = np.average(data[-int(period):])   
            self.i = np.append(self.i, sampled)
        
        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        self.E = self.E[::self.shape.interval][:self.i.size]
        self.i = self.i[:self.E.size]
        
    
    def output(self):
        '''Returns the analysed oscilloscope data for checking or analysis purposes'''

        zipped = zip(self.index, self.E, self.i)        # zipped array containing analysed oscilloscope data
        return zipped