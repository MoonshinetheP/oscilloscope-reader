'''
===================================================================================================
Copyright (C) 2023 Steven Linfield

This file is part of the oscilloscope-reader package. This package is free software: you can 
redistribute it and/or modify it under the terms of the GNU General Public License as published by 
the Free Software Foundation, either version 3 of the License, or (at your option) any later 
version. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details. You should have received a copy of the GNU General 
Public License along with oscilloscope-reader. If not, see https://www.gnu.org/licenses/
===================================================================================================

Package title:      oscilloscope-reader
Repository:         https://github.com/MoonshinetheP/oscilloscope-reader
Date of creation:   22/10/2022
Main author:        Steven Linfield (MoonshinetheP)
Collaborators:      None
Acknowledgements:   None

Filename:           operations.py

===================================================================================================

Description:

This file contains the code used by the oscilloscope-reader package to analyse oscilloscope data,
both simulated and imported. On its own, it will work out the position of the vertex potentials
from the oscilloscope data and update the potential waveform accordingly. Returned data can be in
its raw format, the result of a moving average operation, or the result of a current sampling
routine.

===================================================================================================

How to use this file:
    
This file has no standalone operational capabilities.

===================================================================================================
'''


import sys
import numpy as np


class Operations:

    '''Analyses the given data and uses it to format the given potential waveform \n

    Requires: \n
    shape - an instance of one of the potential waveform classes from the waveforms.py file\n
    data - an instance of either the Capacitance class from the simulations.py file or the Oscilloscope class from the fileopener.py file\n
    MA - a True or False option for whether moving average analysis is performed \n
    window - the window used for moving average anaysis \n
    step - the steps taken in moving average analysis \n 
    CS - a True or False option for whether current sampling analysis is performed \n
    center - the fraction of the step interval where the center of the sampling region is located during current sampling analysis \n
    range - the fraction of the step interval which is averaged during current sampling analysis'''
    
    def __init__(self, shape, data, MA = False, window = 1000, step = 100, CS = False, center = 0.5, range = 0.95):
        
        '''PARAMETER INITIALISATION'''
        self.shape = shape      # potential waveform object generated by waveforms.py
        self.data = data        # simulated or imported oscilloscope data object generated using simulations.py or operations.py
        self.MA = MA        # boolean value which decides if moving average analysis is performed or not
        self.window = window        # window used to average the data in moving average analysis
        self.step = step        # steps by which window is moved in moving average analysis
        self.CS = CS        # boolean value which decides if current sampling analysis is performed or not
        self.center = center      # fraction of interval where the centre of the sampling region is located in current sampling analysis
        self.range = range      # fraction of interval which is averaged in current sampling analysis

        '''DATA TYPE ERRORS'''
        if isinstance(self.MA, (bool)) is False:        # checks that the given moving average option is a Boolean value
            print('\n' + 'An invalid datatype was used for the moving average option. Enter a Boolean value.' + '\n')
            sys.exit()
        if isinstance(self.window, (int)) is False:     # checks that the given moving average window is an integer value
            print('\n' + 'An invalid datatype was used for the moving average window. Enter an integer value.' + '\n')
            sys.exit()
        if isinstance(self.step, (int)) is False:       # checks that the given moving average step is an integer value
            print('\n' + 'An invalid datatype was used for the moving average step. Enter an integer value.' + '\n')
            sys.exit()
        if isinstance(self.CS, (bool)) is False:        # checks that the given current sampling option is a Boolean value
            print('\n' + 'An invalid datatype was used for the current sampling option. Enter a Boolean value.' + '\n')
            sys.exit()
        if isinstance(self.center, (float)) is False:       # checks that the given current sampling center is a float value
            print('\n' + 'An invalid datatype was used for the current sampling center. Enter a float value.' + '\n')
            sys.exit()
        if isinstance(self.range, (float)) is False:        # checks that the given current sampling range is a float value
            print('\n' + 'An invalid datatype was used for the current sampling fraction. Enter a float value.' + '\n')
            sys.exit()

        '''DATA VALUE ERRORS'''
        if self.window <= 1:      # checks that the given moving average window is greater than 1
            print('\n' + 'Moving average window must be greater than 1.' + '\n')
            sys.exit()
        if self.step <= 0:       # checks that the given moving average step is greater than 0
            print('\n' + 'Moving average step must be greater than 0.' + '\n')
            sys.exit() 
        if round(self.center - (self.range / 2), 3) < 0.01:       # checks that the sampling window avoids the very beginning of an interval
            print('\n' + 'Sampling cannot be done in the first 1 percent of an interval.' + '\n')
            sys.exit() 
        if round(self.center + (self.range / 2), 3) > 0.99:       # checks that the sampling window avoids the very end of an interval
            print('\n' + 'Sampling cannot be done in the last 1 percent of an interval.' + '\n')
            sys.exit() 

        '''CONTROL STATEMENTS'''
        if shape.type == 'linear' and data.label == 'simulated':        # imports the potential and avoids the need to find intervals and vertices
            self.E = self.shape.E
        else:       # all other cases need to at least find the intervals 
            self.Peaks()      

        if self.MA == False and self.CS == False:       # returns with unanalysed raw data
            self.Raw()
        if self.MA == True and self.CS == False:        # returns with moving average analysed data
            self.MovingAverage()
        if self.MA == False and self.CS == True:        # returns with current sampling analysed data
            self.CurrentSampling()
        if self.MA == True and self.CS == True:     # restricts both moving average and current sampling analysis from being performed
            print('\n' + 'Both analysis methods have been selected. Please choose either one or neither in order to get the raw data' + '\n')
            sys.exit()


    def Peaks(self):
        '''Uses a moving window to find the position of the maximum point in each interval \n 
        (i.e. the peak of the transient), uses this data to extract the peak values, then \n 
        looks at the difference between peak values to determine where the vertex potentials are \n
        and recalculates the potential waveform used for plotting based on this data'''
        
        '''FINDING PEAK POSITIONS'''
        ix = 0      # counter for the moving analysis window
        self.peaks = np.array([])       # creates an emptry array to hold the positions of all peaks in the imported current array
        while ix < (self.data.i.size - self.shape.interval + 1):        # closes the loop when moving analysis window reaches the end of the imported current array
            self.position = np.argmax(np.abs(self.data.i[ix : ix + self.shape.interval])) + ix      # finds the position of the maximum point (i.e. the peak) in the current analysis window
            if ix == 0:     # allows the first peak to be added without any issues
                self.peaks = np.append(self.peaks, int(self.position))      # adds the found peak position to the peaks array
            elif self.position - self.peaks[-1] > 1.5 * self.shape.interval:        # activates in cases where the analysis window skips a peak for whatever reason
                self.lost = np.argmax(np.abs(self.data.i[int(self.peaks[-1] + 0.5 * self.shape.interval) : int(self.position - 0.5 * self.shape.interval)])) + int(0.5 * self.shape.interval + self.peaks[-1])      # moves the analysis window back by half an interval and looks for the lost peak 
                self.peaks = np.append(self.peaks, int(self.lost))      # adds the lost peak position to the peaks array
                self.peaks = np.append(self.peaks, int(self.position))      # adds the found peak position to the peaks array
            elif self.position - self.peaks[-1] < 0.5 * self.shape.interval:        # activates in cases when the analysis window splits a peak, allowing the second peak to be ignored
                pass
            else:       # for all other cases where peakfinding works as expected
                self.peaks = np.append(self.peaks, int(self.position))      # adds the found peak position to the peaks array
            ix += self.shape.interval       # increases the analysis window by the interval size

        '''FINDING PEAK VALUES'''
        self.values = np.array([])      # creates an empty array to hold the values of each of the peaks found in the previous section
        for iy in self.peaks:       # loops through the peaks array
            self.values = np.append(self.values, self.data.i[int(iy)])      # and adds the current value of the peak to the values array

        '''FINDING VERTEX POTENTIALS'''
        if self.data.label == 'imported':       # all imported data also requires that you find a vertex potential in order to plot vs. the imported potential waveform
            self.changes = np.diff(self.values)     # finds the change in current between two adjacent peaks
            for iw,iz in enumerate(self.changes):     # loops through the changes
                if iz >= np.abs(self.values[iw]):        # checks if the change between two adjacent peaks is more positive than the height of a single peak
                    self.lv = int(self.peaks[np.where(self.changes == iz)[0][0]])       # assigns the position of this change to the lower vertex potential
                    if self.shape.dE > 0:       # activates when step size is positive
                            self.E = np.concatenate((self.shape.E[self.shape.udp + self.shape.dp - self.lv: ], self.shape.E[:self.shape.udp + self.shape.dp -self.lv]))     # and reorganises the imported potential waveform to fit the data 
                    elif self.shape.dE <0:      # activates when step size is negative
                            self.E = np.concatenate((self.shape.E[self.shape.ldp - self.lv: ], self.shape.E[:self.shape.ldp - self.lv]))        # and reorganises the imported potential waveform to fit the data 
                    break       # breaks the loop,because the other vertex potential is not needed
                if iz <= -np.abs(self.values[iw]):         # checks if the change between two adjacent peaks is more negative than the negative height of a single peak
                    self.uv = int(self.peaks[np.where(self.changes == iz)[0][0]])       # assigns the position of this change to the upper vertex potential
                    if self.shape.dE > 0:       # activates when step size is positive
                            self.E = np.concatenate((self.shape.E[self.shape.udp - self.uv: ], self.shape.E[:self.shape.udp - self.uv]))        # and reorganises the imported potential waveform to fit the data 
                    elif self.shape.dE <0:      # activates when step size is negative
                            self.E = np.concatenate((self.shape.E[self.shape.dp + self.shape.ldp - self.uv: ], self.shape.E[:self.shape.dp + self.shape.ldp - self.uv]))        # and reorganises the imported potential waveform to fit the data 
                    break       # breaks the loop,because the other vertex potential is not needed
        else:       # no need to find the vertex potentials for simulated data
            self.E = self.shape.E       # returns the imported potential waveform as it is


    def Raw(self):
        '''Simply returns the oscilloscope data in its raw form'''
        
        self.method = 'no formatting'       # label for file naming
            
        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        self.E = self.E     # potential waveform     
        self.i = self.data.i[:self.E.size]          # raw current    


    def MovingAverage(self):
        '''Uses a moving window to find the average current, then takes a step and repeats until \n
           reaching the end of the current array''' 
        
        self.method = f'moving average analysis using a window of {self.window} and steps of {self.step} '      # label for file naming
        
        ix = 0      # moving window counter
        self.i = np.array([])       # empty array to contain the current
        while ix < self.data.i.size - self.window + 1:      # closes the loop when the window reaches the end of the curent array
            self.i = np.append(self.i, np.average(self.data.i[ix : ix + self.window]))      # appends the average current to the current arraay
            ix += self.step     # increases the moving window counter by a step

        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        self.E = self.E[::self.step][:self.i.size]      # potential waveform sampling at each step and cut to the length of the current array if necessary
        self.i = self.i[:self.E.size]       # current array cut to the length of the potential waveform if necessary
        

    def CurrentSampling(self):
        '''Isolates each interval and performs an averaging operation in a range around a certain \n
           fraction of the interval'''
        
        self.method = f'current sampling analysis using a sampling window of {round(self.range * 100)}% centered at {round(self.center * 100)}%'       #label for file naming

        self.i = np.array([])       # empty array to contain the current
        for ix in range(0, self.peaks.size):        # loops through the size of the peaks array
            try:        # for all but the last step
                self.interval = self.data.i[int(self.peaks[ix]): int(self.peaks[ix + 1])]       # isolates the interval using the peak positions found earlier
            except:     #for the last step
                self.interval = self.data.i[int(self.peaks[ix]):int(self.peaks[ix] + self.shape.interval)]      # isolates the interval using the peak positions found earlier and estimates the end position of the last interval
            self.urange = round((self.center + (self.range / 2)), 3) * self.interval.size     # finds the index for the upper limit of the sampling region
            self.lrange = round((self.center - (self.range / 2)), 3) * self.interval.size     # finds the index for the lower limit of the sampling region
            self.averaged = np.average(self.interval[int(self.lrange) : int(self.urange)])      # averages the current within the sampling region
            self.i = np.append(self.i, self.averaged)       # and appends the result to the current array
        
        self.index = self.shape.index       # indexing array borrowed from waveforms.py (zipping with E and i cuts this automatically)
        for ix in range(0, self.peaks.size):
            if self.peaks[ix] > self.E.size:
                self.E = self.E[self.peaks.astype(int)[ : ix]]     # uses the index of the peaks to work out the potential corresponding to each step, other methods caused some distortion in the plotted data
                break
        self.i = self.i[:self.E.size]       # current array cut to the length of the potential waveform if necessary
        
    
    def output(self):
        '''Returns the analysed oscilloscope data for checking or analysis purposes'''

        zipped = zip(self.index, self.E, self.i)        # zipped array containing analysed oscilloscope data
        return zipped