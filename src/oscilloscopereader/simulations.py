'''
===================================================================================================
Copyright (C) 2023 Steven Linfield

This file is part of the oscilloscope-reader package. This package is free software: you can 
redistribute it and/or modify it under the terms of the GNU General Public License as published by 
the Free Software Foundation, either version 3 of the License, or (at your option) any later 
version. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details. You should have received a copy of the GNU General 
Public License along with oscilloscope-reader. If not, see https://www.gnu.org/licenses/
===================================================================================================

Package title:      oscilloscope-reader
Repository:         https://github.com/MoonshinetheP/oscilloscope-reader
Date of creation:   22/10/2022
Main author:        Steven Linfield (MoonshinetheP)
Collaborators:      None
Acknowledgements:   None

Filename:           simulations.py

===================================================================================================

Description:

This file contains the code used by the oscilloscope-reader package to generate simulated data for
capactive charging using an instance of either the CyclicLinearVoltammetry class or the 
CyclicStaircaseVoltammetry class from the waveforms.py file.

===================================================================================================

How to use this file:
    
Whilst this file is designed for use by the operations.py file, it can also be used on its own in 
order to visualise and analyse the effect of staircase waveforms on the analogue current.

In order to use this file:
    1. Scroll down the the bottom of the file, to the 'RUNNING SIMULATIONS FROM MAIN' section.
    2. In the third point of this section, choose the waveform you want to use, commenting out the 
       other waveform
    3. Edit the parameters of this waveform, keeping the following rules in mind
        a) If you want a scan going in the negative direction, use a negative dE value. 
        b) Negative dE values cannot be used when the start potential is the lower vertex potential
        c) Positive dE values cannot be used when the start potential is the upper vertex potential
        d) An oscilloscope sampling frequency (osf) of None gives a data point for each dE value
        e) Increasing the osf will increase the number of data points for each dE
        f) The osf cannot be set below the natural sampling frequency (given by sr/dE)
    4. In the fourth point of this section, choose the time constant parameters you want for the 
       generated data
    5. Run the python file

The simulated data will be saved in a .txt file in the /data folder of the current working
directory.

===================================================================================================
'''


import sys
import os
import time
import numpy as np
from errno import EEXIST
import waveforms as wf


class Capacitance:
    
    '''Creates a basic simulation of capacitive charging based on the nature of an imported potential waveform \n
    
    Requires: \n
    shape - an instance of one of the potential waveform classes from the waveforms.py file \n
    Cd - double layer capacitance (in F) \n
    Ru - uncompensated resistance (in Ω) \n'''

    def __init__(self, shape, Cd = 0.000050, Ru = 500):
        
        '''PARAMETER INITIALISATION'''
        self.label  = 'simulated'       # label for file naming and for use in operations.py

        self.shape = shape      # potential waveform object generated by waveforms.py
        self.Eini = shape.Eini  # initial potential (in V)
        self.Eupp = shape.Eupp      # upper vertex potential (in V)
        self.Elow = shape.Elow      # lower vertex potential (in V)
        self.dE = shape.dE      # step size (in V)
        self.sr = shape.sr      # scan rate (in V/s)
        self.ns = shape.ns      # number of scans
        self.osf = shape.osf        # oscilloscope sampling frequency (in Sa/s)

        self.Cd = Cd        # double layer capacitance (in F)
        self.Ru = Ru        # uncompensated resistance (in Ω)
        
        '''DATATYPE ERRORS'''
        if isinstance(self.Cd, (float)) is False:        # checks that the given double layer capacitance is a float value
            print('\n' + 'An invalid datatype was used for the double layer capacitance. Enter a float value corresponding to the capacitance in F.' + '\n')
            sys.exit()
        if isinstance(self.Ru, (float, int)) is False:        # checks that the given uncompensated resistance is either a float or an integer value
            print('\n' + 'An invalid datatype was used for the uncompensated resistance. Enter either a float or an integer value corresponding to resistance in Ohms.' + '\n')
            sys.exit()

        '''DATA VALUE ERRORS'''
        if self.Cd > 0:      # checks that the given double layer capacitance is greater than 0
            print('\n' + 'Double layer capacitance must be a positive non-zero value' + '\n')
            sys.exit()
        if self.Ru > 0:       #checks that the given uncompensated resistance is greater than 0
            print('\n' + 'Uncompensated resistnace must be a positive non-zero value' + '\n')
            sys.exit() 

        '''CONTROL STATEMENTS'''         
        if self.shape.type == 'linear':     # activates in cases where simulations are performed using a linear waveform
            self.linear()
        if self.shape.type == 'staircase':      # activates in cases where simulations are performed using a staircase waveform
            self.staircase() 


    def linear(self):
        '''Returns E vs. i for a CV performed on a capacitor with parameters derived from the Capacitance() class\n
        Uses equation 1.6.23 from the 3rd edition of Electrochemical Methods:\n
        i = sr*Cd*(1-np.exp(-t/(Ru*Cd)))'''
        
        self.i = np.array([0])      # creates a current array containing the initial current value at rest potential (0)
        
        '''STARTING FROM LOWER VERTEX POTENTIAL'''
        if self.Eini == self.Elow:      # activates in cases where the initial potential is equal to the lower vertex potential
            for iy in range(0, self.ns):        # loops through the number of scans
                self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))     # appends the current from the positive scan direction portion of the potential window to the current array
                self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))        # appends the current from the negative scan direction portion of the potential window to the current array
        
        '''STARTING FROM UPPER VERTEX POTENTIAL'''        
        if self.Eini == self.Eupp:      # activates in cases where the initial potential is equal to the upper vertex potential
            for iy in range(0, self.ns):        # loops through the number of scans
                self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))        # appends the current from the negative scan direction portion of the potential window to the current array
                self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))     # appends the current from the positive scan direction portion of the potential window to the current array
        
        '''STARTING IN BETWEEN VERTEX POTENTIALS'''
        if self.Elow < self.Eini < self.Eupp:      # activates in cases where the initial potential is between the lower vertexpotential and the upper vertex potential
            '''POSITIVE SCAN DIRECTION'''
            if self.dE > 0:      # activates in cases where the step size is positive
                for iy in range(0, self.ns):        # loops through the number of scans
                    if iy == 0:        # for the first scan
                        self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.udp]) / (self.Ru * self.Cd))))        # appends the current from the positive scan direction portion of the upper partial potential window to the current array
                        self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))        # appends the current from the negative scan direction portion of the potential window to the current array
                    else:       # for all subsequent scans
                        self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))     # appends the current from the positive scan direction portion of the potential window to the current array
                        self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))        # appends the current from the negative scan direction portion of the potential window to the current array
                self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.ldp]) / (self.Ru * self.Cd))))        # appends the current from the final positive scan direction portion of the lower partial potential window to the current array
            '''NEGATIVE SCAN DIRECTION'''
            if self.dE < 0:      # activates in cases where the step size is negative
                for iy in range(0, self.ns):        # loops through the number of scans
                    if iy == 0:        # for the first scan
                        self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.ldp]) / (self.Ru * self.Cd))))       # appends the current from the negative scan direction portion of the lower partial potential window to the current array
                        self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))     # appends the current from the positive scan direction portion of the potential window to the current array
                    else:       # for all subsequent scans
                        self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))         # appends the current from the negative scan direction portion of the potential window to the current array
                        self.i = np.append(self.i, self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.dp]) / (self.Ru * self.Cd))))     # appends the current from the positive scan direction portion of the potential window to the current array
                self.i = np.append(self.i, -self.sr * self.Cd * (1 - np.exp((-self.shape.t[:self.shape.udp]) / (self.Ru * self.Cd))))       # appends the current from the final negative scan direction portion of the upper partial potential window to the current array


    def staircase(self):
        '''Returns E vs. i for a CSV performed on a capacitor with parameters derived from the Capacitance() class\n
        Uses equation 1.6.17 from the 3rd edition of Electrochemical Methods:\n
        i = (dE/Ru)*np.exp(-t/(Ru*Cd))'''   
        
        self.i = np.array([0])      # creates a current array containing the initial current value at rest potential (0)
        
        self.iplus = np.zeros(self.shape.dp)        # creates an empty array to hold current from the positive scan direction portion of the potential window
        self.iminus = np.zeros(self.shape.dp)        # creates an empty array to hold current from the negative scan direction portion of the potential window        
        self.iupp = np.zeros(self.shape.udp)        # creates an empty array to hold current from the upper partial potential window
        self.ilow = np.zeros(self.shape.ldp)        # creates an empty array to hold current from the lower partial potential window  

        '''STARTING FROM LOWER VERTEX POTENTIAL'''
        if self.Eini == self.Elow:      # activates in cases where the initial potential is equal to the lower vertex potential
            for ix in range(0, self.ns):        # loops through the number of scans
                for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                    space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.iplus[space:] = np.add(self.iplus[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))      # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                    space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.iminus[space:] = np.add(self.iminus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                self.i = np.append(self.i, self.iplus)      # appends the current from the positive scan direction portion of the potential window to the current array
                self.iplus = np.zeros(self.shape.dp)        # empties the array to hold current from the positive scan direction portion of the potential window
                self.i = np.append(self.i, self.iminus)     # appends the current from the negative scan direction portion of the potential window to the current array
                self.iminus = np.zeros(self.shape.dp)       # empties the array to hold current from the negative scan direction portion of the potential window
        
        '''STARTING FROM UPPER VERTEX POTENTIAL'''
        if self.Eini == self.Eupp:      # activates in cases where the initial potential is equal to the upper vertex potential
            for ix in range(0, self.ns):        # loops through the number of scans
                for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                    space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.iminus[space:] = np.add(self.iminus[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))        # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                    space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.iplus[space:] = np.add(self.iplus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))     # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                self.i = np.append(self.i, self.iminus)     # appends the current from the negative scan direction portion of the potential window to the current array
                self.iminus = np.zeros(self.shape.dp)        # empties the array to hold current from the negative scan direction portion of the potential window
                self.i = np.append(self.i, self.iplus)      # appends the current from the positive scan direction portion of the potential window to the current array
                self.iplus = np.zeros(self.shape.dp)        # empties the array to hold current from the positive scan direction portion of the potential window 

        '''STARTING IN BETWEEN VERTEX POTENTIALS'''
        if self.Elow < self.Eini < self.Eupp:       # activates in cases where the initial potential is in between the lower vertex potential and the upper vertex potential
            
            '''POSITIVE SCAN DIRECTION'''
            if self.dE > 0:      # activates in cases where the step size is positive
                for ix in range(0, self.ns):        # loops through the number of scans
                    if ix == 0:       # for the first scan
                        for iy in range(0, self.shape.usteps):      # loops through the number of steps in a upper partial potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iupp[space:] = np.add(self.iupp[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.udp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the upper partial potential window and buffers the start with a blank array
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iminus[space:] = np.add(self.iminus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                        self.i = np.append(self.i, self.iupp)       # appends the current from the positive scan direction portion of the upper partial potential window to the current array
                        self.i = np.append(self.i, self.iminus)     # appends the current from the negative scan direction portion of the potential window to the current array
                        self.iminus = np.zeros(self.shape.dp)       # empties the array to hold current from the negative scan direction portion of the potential window
                    else:       # for all subsequent scans
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iplus[space:] = np.add(self.iplus[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))      # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iminus[space:] = np.add(self.iminus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                        self.i = np.append(self.i, self.iplus)      # appends the current from the positive scan direction portion of the potential window to the current array
                        self.iplus = np.zeros(self.shape.dp)        # empties the array to hold current from the positive scan direction portion of the potential window
                        self.i = np.append(self.i, self.iminus)     # appends the current from the negative scan direction portion of the potential window to the current array
                        self.iminus = np.zeros( self.shape.dp)        # empties the array to hold current from the negative scan direction portion of the potential window
                for iz in range(0, self.shape.lsteps):      # loops through the number of steps in a lower partial potential window
                    space = int(iz * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.ilow[space:] = np.add(self.ilow[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.ldp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the lower partial potential window and buffers the start with a blank array   
                self.i = np.append(self.i, self.ilow)       # appends the current from the final positive scan direction portion of the lower partial potential window to the current array
            
            '''NEGATIVE SCAN DIRECTION'''
            if self.dE < 0:      # activates in cases where the step size is positive
                for ix in range(0, self.ns):        # loops through the number of scans
                    if ix == 0:       # for the first scan
                        for iy in range(0, self.shape.lsteps):      # loops through the number of steps in a lower partial potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.ilow[space:] = np.add(self.ilow[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.ldp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the lower partial potential window and buffers the start with a blank array
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iplus[space:] = np.add(self.iplus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))     # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                        self.i = np.append(self.i, self.ilow)       # appends the current from the negative scan direction portion of the lower partial potential window to the current array
                        self.i = np.append(self.i, self.iplus)      # appends the current from the positive scan direction portion of the potential window to the current array
                        self.iplus = np.zeros(self.shape.dp)        # empties the array to hold current from the positive scan direction portion of the potential window
                    else:       # for all subsequent scans
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iminus[space:] = np.add(self.iminus[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))        # calculates current from this step for the remainder of the potential window and buffers the start with a blank array
                        for iy in range(0, self.shape.steps):       # loops through the number of steps in the potential window
                            space = int(iy * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                            self.iplus[space:] = np.add(self.iplus[space:], (-self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.dp - space]) / (self.Ru * self.Cd)))     # calculates current from this step for the remainder of the potential window and buffers the start with a blank array   
                        self.i = np.append(self.i, self.iminus)     # appends the current from the negative scan direction portion of the potential window to the current array
                        self.iminus = np.zeros(self.shape.dp)       # empties the array to hold current from the negative scan direction portion of the potential window
                        self.i = np.append(self.i, self.iplus)      # appends the current from the positive scan direction portion of the potential window to the current array
                        self.iplus = np.zeros(self.shape.dp)        # empties the array to hold current from the postive scan direction portion of the potential window
                for iz in range(0, self.shape.usteps):      # loops through the number of steps in a upper partial potential window
                    space = int(iz * self.shape.interval)       # calulates the number of sampling points in the steps for which current has already been calculated
                    self.iupp[space:] = np.add(self.iupp[space:], (self.dE/self.Ru) * np.exp((-self.shape.t[:self.shape.udp - space]) / (self.Ru * self.Cd)))       # calculates current from this step for the remainder of the upper partial potential window and buffers the start with a blank array 
                self.i = np.append(self.i, self.iupp)       # appends the current from the final negative scan direction portion of the upper partial potential window to the current array

    
    def output(self):
        '''Returns the simulated data for checking or analysis purposes'''
        
        zipped = zip(self.shape.t, self.shape.E, self.i)      # zipped array containing simulation data
        return zipped



"""
===================================================================================================
RUNNING SIMULATIONS FROM MAIN
===================================================================================================
"""

if __name__ == '__main__':
    
    '''1. MAKE A /DATA FOLDER''' 
    cwd = os.getcwd()

    try:
        os.makedirs(cwd + '/data')
    except OSError as exc:
        if exc.errno == EEXIST and os.path.isdir(cwd + '/data'):
            pass
        else: 
            raise

    '''2. DEFINE THE START TIME'''
    start = time.time()  

    '''3. DESCRIBE THE WAVEFORM'''
    #shape = wf.CyclicLinearVoltammetry(Eini = 0, Eupp = 0.5, Elow = -0.50, dE = 0.002, sr = 0.5, ns = 1, osf = 2000000)
    shape = wf.CyclicStaircaseVoltammetry(Eini = 0, Eupp = 0.5, Elow = -0.5, dE = 0.002, sr = 0.5, ns = 1, osf = 2000000)
    
    '''4. DESCRIBE THE SIMULATION CONDITIONS'''
    data = Capacitance(shape, Cd = 0.000050, Ru = 250)

    '''5. SAVE THE DATA'''
    filepath = f'{cwd}/data/{time.strftime("%Y-%m-%d %H-%M-%S")} {data.label} {shape.label} data.txt'
    with open(filepath, 'w') as file:
        for ix, iy, iz in data.output():
            file.write(str(ix) + ',' + str(iy) + ',' + str(iz) + '\n')
    
    '''6. DEFINE THE END TIME'''
    end = time.time()
    print(f'The simulation took {end-start} seconds to complete')